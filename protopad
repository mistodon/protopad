#!/usr/bin/env python3

from google.protobuf import json_format
from google.protobuf.descriptor import FieldDescriptor
import argparse
import pkgutil
import json
import os
import pprint
import shutil
import subprocess
import sys


DOTFILE_PATH = os.path.expanduser("~/.protopad/config.json")
TEMPFILE_PATH = os.path.expanduser("~/.protopad/temp.json")


def protopad(args):
    app = Protopad(args["verbose"])

    message_type_descriptor = app.get_message_type_descriptor(args["type"]) if "type" in args else None

    task = args["task"]
    if task == "json":
        app.read_to_json(message_type_descriptor, args.get("file"), args.get("output"))
    elif task == "proto":
        app.read_to_proto(message_type_descriptor, args.get("file"), args.get("output"))
    elif task == "edit":
        app.edit_message(message_type_descriptor, args.get("file"), args.get("output"), args["empty"], args["recent"])
    elif task == "register":
        if args["list"]:
            app.list_registered_paths()
        elif args["recompile"]:
            app.recompile_protos()
        else:
            app.register_proto_path(args["path"], args["remove"])
    else:
        assert False, "Unreachable code!"


class Protopad:
    def __init__(self, verbose=False):
        self.verbose = verbose

    def log(self, text, always=False):
        if self.verbose or always:
            print(text)

    def get_message_type_descriptor(self, message_type_name):
        import_path = os.path.expanduser("~/.protopad/compiled")
        options = []
        for loader, module_name, is_pkg in pkgutil.walk_packages([import_path]):
            try:
                self.log(f"Loading module: {module_name}")
                module = loader.find_module(module_name).load_module(module_name)
                descriptor = getattr(module, "DESCRIPTOR", None)
                if descriptor:
                    for message_type, message_desc in descriptor.message_types_by_name.items():
                        self.log(f"  Found message type: {message_type}")
                        options.append((message_type, message_desc, module_name))
                else:
                    self.log(f"  No descriptor in module.")
            except AssertionError:
                self.log(f"  (Module {module_name} could not be loaded.)")
                continue

        if not options:
            print("Failed to load any message types at all.")
            print("Check your registered paths with `protopad register --list`")
            exit(1)

        selection = [option for option in options if option[0] == message_type_name]
        if not selection:
            print(f"Unknown message type '{message_type_name}'")
            exit(1)
        elif len(selection) > 1:
            print(f"Message type '{message_type_name}' is ambiguous. (TODO: allow specifying which to use)")
            exit(1)

        (_, desc, _) = selection[0]
        return desc


    def read_to_json(self, message_type_descriptor, infile, outfile):
        base = read_any_input(message_type_descriptor, infile)
        result = json_format.MessageToJson(base)

        if outfile:
            with open(outfile, "w") as f:
                f.write(result)
        else:
            print(result)


    def read_to_proto(self, message_type_descriptor, infile, outfile):
        base = read_any_input(message_type_descriptor, infile)
        result = base.SerializeToString()

        if outfile:
            with open(outfile, "wb") as f:
                f.write(result)
        else:
            sys.stdout.buffer.write(result)


    def edit_message(self, message_type_descriptor, infile, outfile, empty, recent):
        filename = TEMPFILE_PATH if recent else infile
        base = read_any_input(message_type_descriptor, filename) if filename else create_template_message(message_type_descriptor, empty)
        json = json_format.MessageToJson(base, including_default_value_fields=True)

        self.log("Launching editor... (quit editor when finished)")
        edited_json = interactive_edit_message(json)
        self.log("Done.")

        resulting_message = json_format.Parse(edited_json, message_type_descriptor._concrete_class())
        result = resulting_message.SerializeToString()

        if outfile:
            with open(outfile, "wb") as f:
                f.write(result)
        else:
            sys.stdout.buffer.write(result)

    def list_registered_paths(self):
        with open(DOTFILE_PATH, "r") as f:
            config = json.load(f)

        paths = set(config.get("paths", []))
        for path in paths:
            print(path)


    def register_proto_path(self, path, remove):
        assert path is not None
        action = "Unregistering" if remove else "Registering"
        self.log(f"{action} path: {path}")

        with open(DOTFILE_PATH, "r") as f:
            config = json.load(f)

        paths = set(config.get("paths", []))

        if remove:
            paths.remove(path)
        else:
            paths.add(path)

        self.log("Updated paths:")
        for path in paths:
            self.log(f"- {path}")

        paths = config["paths"] = list(paths)

        with open(DOTFILE_PATH, "w") as f:
            json.dump(config, f)

        self.recompile_protos()


    def recompile_protos(self):
        self.log("Recompiling proto definitions...")
        with open(DOTFILE_PATH, "r") as f:
            config = json.load(f)

        paths = set(config.get("paths", []))

        output_dir = os.path.expanduser("~/.protopad/compiled")
        shutil.rmtree(output_dir, ignore_errors=True)
        os.makedirs(output_dir)

        for path in paths:
            for (dirpath, _, filenames) in os.walk(path):
                self.log(f"  Compiling modules in {dirpath}")
                for filename in filenames:
                    filename = os.path.join(dirpath, filename)
                    command = f"protoc -I {path} --python_out {output_dir} {filename}"
                    self.log(f"    Executing: {command}")
                    stdoutdata = subprocess.getoutput(command)

                    if stdoutdata:
                        self.log(f"      (protoc) {stdoutdata}")
        self.log("Done.")

        print()
        self.generate_module_roots()

    def generate_module_roots(self):
        self.log("Generating module roots...")
        dirs = []
        compiled_dir = os.path.expanduser("~/.protopad/compiled")
        for (dirpath, _, _) in os.walk(compiled_dir):
            self.log(f"  Creating module root in {dirpath}")
            rootpath = os.path.join(dirpath, "__init__.py")
            open(rootpath, "a").close()
        self.log("Done.")


def read_any_input(message_type_descriptor, filename=None):
    if filename:
        with open(filename, "rb") as f:
            data = f.read()
    else:
        data = sys.stdin.read()

    base = message_type_descriptor._concrete_class()

    try:
        json_format.Parse(data, base)
    except json_format.ParseError:
        base.ParseFromString(data)

    return base


def interactive_edit_message(message_json):
    editor = os.environ["EDITOR"]

    with open(TEMPFILE_PATH, "w") as f:
        f.write(message_json)

    result = subprocess.run(f"{editor} {TEMPFILE_PATH}", shell=True)

    with open(TEMPFILE_PATH, "r") as f:
        edited_result = f.read()

    return edited_result


def create_template_message(message_descriptor, empty):
    message_class = message_descriptor._concrete_class
    base = message_class()
    if not empty:
        for field in message_descriptor.fields:
            if field.label == FieldDescriptor.LABEL_REPEATED and field.message_type:
                placeholder_value = create_template_message(field.message_type, False)
                field_container = getattr(base, field.name, None)
                try:
                    # Repeated type
                    dest = field_container.add()
                    dest.MergeFrom(placeholder_value)
                except AttributeError:
                    # Map type - leave blank for now
                    pass
            elif field.message_type:
                getattr(base, field.name).MergeFrom(create_template_message(field.message_type, False))
    return base


def ensure_dotfiles_exist():
    os.makedirs(os.path.expanduser("~/.protopad/compiled"), exist_ok=True)
    if not os.path.exists(DOTFILE_PATH):
        with open(DOTFILE_PATH, "w") as f:
            json.dump({}, f)


if __name__ == "__main__":
    ensure_dotfiles_exist()
    parser = argparse.ArgumentParser(
            prog="protopad",
            usage="create protobuf files from the terminal")

    parser.add_argument(
            "--verbose", "-v", help="enable verbose logging", action="store_true")

    subparsers = parser.add_subparsers(help="subcommands")

    json_cmd_parser = subparsers.add_parser(
            "json", help="read a JSON or protobuf message and output JSON")
    json_cmd_parser.set_defaults(task="json")
    json_cmd_parser.add_argument(
            "type", help="the protobuf message type")
    json_cmd_parser.add_argument(
            "file", help="the file to read, or stdin if not specified", nargs="?")
    json_cmd_parser.add_argument(
            "--output", "-o", help="a file to write to, or stdout if not specified")

    proto_cmd_parser = subparsers.add_parser(
            "proto", help="read a JSON or protobuf message and output protobuf")
    proto_cmd_parser.set_defaults(task="proto")
    proto_cmd_parser.add_argument(
            "type", help="the protobuf message type")
    proto_cmd_parser.add_argument(
            "file", help="the file to read, or stdin if not specified", nargs="?")
    proto_cmd_parser.add_argument(
            "--output", "-o", help="a file to write to, or stdout if not specified")

    edit_cmd_parser = subparsers.add_parser(
            "edit", help="create or edit a protobuf message in an editor")
    edit_cmd_parser.set_defaults(task="edit")
    edit_cmd_parser.add_argument(
            "type", help="the protobuf message type")
    edit_group = edit_cmd_parser.add_mutually_exclusive_group()
    edit_group.add_argument(
            "file", help="an input file to use as a template, or a default message if not specified", nargs="?")
    edit_group.add_argument(
            "--empty", "-e",
            help="use a completely empty message instead of the default",
            action="store_true")
    edit_group.add_argument(
            "--recent", help="use the most recent edit as a template",
            action="store_true")
    edit_cmd_parser.add_argument(
            "--output", "-o", help="a file to write to, or stdout if not specified")

    register_cmd_parser = subparsers.add_parser(
            "register", help="register a folder of protobuf definitions")
    register_cmd_parser.set_defaults(task="register")
    register_group = register_cmd_parser.add_mutually_exclusive_group(required=True)
    register_group.add_argument(
            "path", help="path to a folder containing protobuf definitions (searched recursively)", nargs="?")
    register_group.add_argument(
            "--list", "-l", help="list the paths that are currently registered",
            action="store_true")
    register_group.add_argument(
            "--recompile",
            help="recompiles registered proto definitions (this happens automatically when registering)",
            action="store_true")
    register_cmd_parser.add_argument(
            "--remove", "-r", help="un-register this path",
            action="store_true")

    args = vars(parser.parse_args())
    if "task" not in args:
        parser.print_help()
        exit(2)
    protopad(args)
