#!/usr/bin/env python3

from google.protobuf import json_format
from google.protobuf.descriptor import FieldDescriptor
import argparse
import pkgutil
import json
import os
import shutil
import subprocess
import sys


DOTFILE_PATH = os.path.expanduser("~/.protopad/config.json")
TEMPFILE_PATH = os.path.expanduser("~/.protopad/temp.json")


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def protopad(args):
    app = Protopad(args["verbose"])

    message_type_descriptor = app.get_message_type_descriptor(args["type"]) if "type" in args else None
    internal_type = args.get("internal_type")
    internal_type_descriptor = app.get_message_type_descriptor(internal_type) if internal_type else None

    task = args["task"]
    if task == "json":
        app.read_to_json(message_type_descriptor, internal_type_descriptor, args.get("file"), args.get("output"))
    elif task == "proto":
        app.read_to_proto(message_type_descriptor, internal_type_descriptor, args.get("file"), args.get("output"))
    elif task == "edit":
        if not (sys.stdin.isatty() and sys.stdout.isatty()):
            eprint("Cannot use terminal pipes with the edit command")
            eprint("Use the `file` and `--output` parameters instead")
            exit(1)
        app.edit_message(message_type_descriptor, internal_type_descriptor, args.get("file"), args.get("output"), args["empty"], args["recent"])
    elif task == "register":
        if args["list"]:
            app.list_registered_paths()
        elif args["recompile"]:
            app.recompile_protos()
        else:
            app.register_proto_path(args["path"], args["remove"])
    else:
        assert False, "Unreachable code!"


class Protopad:
    def __init__(self, verbose=False):
        self.verbose = verbose

    def log(self, text, always=False):
        if self.verbose or always:
            eprint(text)

    def get_message_type_descriptor(self, message_type_name):
        split_name = message_type_name.rsplit(".", 1)
        message_type_name = split_name[-1]
        prefix = split_name[0] if len(split_name) > 1 else ""

        import_path = os.path.expanduser("~/.protopad/compiled")
        options = []
        for loader, module_name, is_pkg in pkgutil.walk_packages([import_path]):
            try:
                self.log(f"Loading module: {module_name}")
                module = loader.find_module(module_name).load_module(module_name)
                descriptor = getattr(module, "DESCRIPTOR", None)
                if descriptor:
                    for message_type, message_desc in descriptor.message_types_by_name.items():
                        self.log(f"  Found message type: {message_type}")
                        options.append((message_type, message_desc, module_name))
                else:
                    self.log(f"  No descriptor in module.")
            except AssertionError:
                self.log(f"  (Module {module_name} could not be loaded.)")
                continue

        if not options:
            eprint("Failed to load any message types at all.")
            eprint("Check your registered paths with `protopad register --list`")
            exit(1)

        selection = [option
                for option in options
                if option[0] == message_type_name and prefix in option[2]]

        if not selection:
            eprint(f"Unknown message type '{message_type_name}'")
            exit(1)
        elif len(selection) > 1:
            eprint(f"Message type '{message_type_name}' is ambiguous. Possibilities are:")
            for (name, _, module_name) in selection:
                eprint(f"- {module_name}.{name}")
            eprint(f"Add any unambiguous prefix to the type name to specify. (e.g. `prefix.TypeName`)")
            exit(1)

        (_, desc, _) = selection[0]
        return desc


    def read_to_json(self, message_type_descriptor, internal_type_descriptor, infile, outfile):
        base = read_any_input(message_type_descriptor, internal_type_descriptor, infile)
        result = proto_to_json(base, internal_type_descriptor)

        if outfile:
            with open(outfile, "w") as f:
                f.write(result)
        else:
            print(result)


    def read_to_proto(self, message_type_descriptor, internal_type_descriptor, infile, outfile):
        base = read_any_input(message_type_descriptor, internal_type_descriptor, infile)
        result = base.SerializeToString()

        if outfile:
            with open(outfile, "wb") as f:
                f.write(result)
        else:
            sys.stdout.buffer.write(result)


    def edit_message(self, message_type_descriptor, internal_type_descriptor, infile, outfile, empty, recent):
        filename = TEMPFILE_PATH if recent else infile
        base = read_any_input(message_type_descriptor, internal_type_descriptor, filename) if filename else create_template_message(message_type_descriptor, empty)
        json = proto_to_json(base, internal_type_descriptor, including_default_value_fields=True)

        self.log("Launching editor... (quit editor when finished)")
        edited_json = interactive_edit_message(json)
        self.log("Done.")

        resulting_message = json_to_proto(edited_json, message_type_descriptor, internal_type_descriptor)
        result = resulting_message.SerializeToString()

        if outfile:
            with open(outfile, "wb") as f:
                f.write(result)
        else:
            sys.stdout.buffer.write(result)

    def list_registered_paths(self):
        with open(DOTFILE_PATH, "r") as f:
            config = json.load(f)

        paths = set(config.get("paths", []))
        for path in paths:
            print(path)


    def register_proto_path(self, path, remove):
        assert path is not None
        action = "Unregistering" if remove else "Registering"
        self.log(f"{action} path: {path}")

        with open(DOTFILE_PATH, "r") as f:
            config = json.load(f)

        paths = set(config.get("paths", []))

        if remove:
            paths.remove(path)
        else:
            paths.add(path)

        self.log("Updated paths:")
        for path in paths:
            self.log(f"- {path}")

        paths = config["paths"] = list(paths)

        with open(DOTFILE_PATH, "w") as f:
            json.dump(config, f)

        self.recompile_protos()


    def recompile_protos(self):
        self.log("Recompiling proto definitions...")
        with open(DOTFILE_PATH, "r") as f:
            config = json.load(f)

        paths = set(config.get("paths", []))

        output_dir = os.path.expanduser("~/.protopad/compiled")
        shutil.rmtree(output_dir, ignore_errors=True)
        os.makedirs(output_dir)

        for path in paths:
            for (dirpath, _, filenames) in os.walk(path):
                self.log(f"  Compiling modules in {dirpath}")
                for filename in filenames:
                    filename = os.path.join(dirpath, filename)
                    command = f"protoc -I {path} --python_out {output_dir} {filename}"
                    self.log(f"    Executing: {command}")
                    stdoutdata = subprocess.getoutput(command)

                    if stdoutdata:
                        self.log(f"      (protoc) {stdoutdata}")
        self.log("Done.")

        self.log("")
        self.generate_module_roots()

    def generate_module_roots(self):
        self.log("Generating module roots...")
        dirs = []
        compiled_dir = os.path.expanduser("~/.protopad/compiled")
        for (dirpath, _, _) in os.walk(compiled_dir):
            self.log(f"  Creating module root in {dirpath}")
            rootpath = os.path.join(dirpath, "__init__.py")
            open(rootpath, "a").close()
        self.log("Done.")


def read_any_input(message_type_descriptor, internal_type_descriptor, filename=None):
    if filename:
        with open(filename, "rb") as f:
            data = f.read()
    else:
        data = sys.stdin.read()

    try:
        return json_to_proto(data, message_type_descriptor, internal_type_descriptor)
    except (json_format.ParseError, json.decoder.JSONDecodeError):
        base = message_type_descriptor._concrete_class()
        base.ParseFromString(data)
        return base


def json_to_proto(json, message_type_descriptor, internal_type_descriptor):
    base = message_type_descriptor._concrete_class()
    (doctored_json, internals) = extract_internal_protos(json, base, internal_type_descriptor)
    json_format.Parse(doctored_json, base)
    if internals:
        reinstate_internals(internals, base)
    return base


def temp_json_name(pyname):
    if "_" not in pyname:
        return pyname

    words = pyname.split("_")
    late_words = [w.capitalize() for w in words[1:]]
    words = [words[0]] + late_words
    return "".join(words)


def proto_to_json(message, internal_type_descriptor, including_default_value_fields=False):
    json_encoded = json_format.MessageToJson(
            message,
            including_default_value_fields=including_default_value_fields)

    if internal_type_descriptor is None:
        return json_encoded

    data = json.loads(json_encoded)

    def unpack_internals(desc, message, obj):
        for field in desc.fields:
            json_field_name = temp_json_name(field.name)
            if field.type == FieldDescriptor.TYPE_BYTES:
                internal_bytes = getattr(message, field.name)
                obj.pop(json_field_name)
                internal_message = internal_type_descriptor._concrete_class()
                internal_message.ParseFromString(internal_bytes)
                internal_message_json = json_format.MessageToJson(
                        internal_message,
                        including_default_value_fields=including_default_value_fields)
                obj[json_field_name] = json.loads(internal_message_json)
            elif field.message_type:
                unpack_internals(field.message_type, getattr(message, field.name), obj[json_field_name])

    unpack_internals(message.DESCRIPTOR, message, data)

    return json.dumps(data, indent=2)


def extract_internal_protos(json_string, base_message, internal_type_descriptor):
    if internal_type_descriptor is None:
        return (json_string, None)

    def extract_internals(desc, obj, internals, path):
        for field in desc.fields:
            field_path = path + [field.name]
            json_field_name = temp_json_name(field.name)
            if field.type == FieldDescriptor.TYPE_BYTES:
                internal_obj = obj.pop(json_field_name)
                internal_json = json.dumps(internal_obj)
                internal_base = internal_type_descriptor._concrete_class()
                internal_message = json_format.Parse(internal_json, internal_base)
                internals.append((field_path, internal_message))
            elif field.message_type:
                extract_internals(field.message_type, obj[json_field_name], internals, field_path)

    desc = base_message.DESCRIPTOR
    data = json.loads(json_string)
    internals = []
    extract_internals(desc, data, internals, [])

    return (json.dumps(data), internals)


def reinstate_internals(internals, message):
    for path, internal_message in internals:
        binary = internal_message.SerializeToString()
        target = message
        for field_name in path[:-1]:
            target = getattr(target, field_name)
        setattr(target, path[-1], binary)


def interactive_edit_message(message_json):
    editor = os.environ["EDITOR"]

    with open(TEMPFILE_PATH, "w") as f:
        f.write(message_json)

    result = subprocess.run(f"{editor} {TEMPFILE_PATH}", shell=True)

    with open(TEMPFILE_PATH, "r") as f:
        edited_result = f.read()

    return edited_result


def create_template_message(message_descriptor, empty):
    message_class = message_descriptor._concrete_class
    base = message_class()
    if not empty:
        for field in message_descriptor.fields:
            if field.message_type:
                if field.label == FieldDescriptor.LABEL_REPEATED:
                    placeholder_value = create_template_message(field.message_type, False)
                    field_container = getattr(base, field.name, None)
                    try:
                        # Repeated type
                        dest = field_container.add()
                        dest.MergeFrom(placeholder_value)
                    except AttributeError:
                        # Map type - leave blank for now
                        pass
                else:
                    getattr(base, field.name).MergeFrom(create_template_message(field.message_type, False))
    return base


def ensure_dotfiles_exist():
    os.makedirs(os.path.expanduser("~/.protopad/compiled"), exist_ok=True)
    if not os.path.exists(DOTFILE_PATH):
        with open(DOTFILE_PATH, "w") as f:
            json.dump({}, f)


if __name__ == "__main__":
    ensure_dotfiles_exist()
    parser = argparse.ArgumentParser(
            prog="protopad",
            usage="create protobuf files from the terminal")

    parser.add_argument(
            "--verbose", "-v", help="enable verbose logging", action="store_true")

    subparsers = parser.add_subparsers(help="subcommands")

    json_cmd_parser = subparsers.add_parser(
            "json", help="read a JSON or protobuf message and output JSON")
    json_cmd_parser.set_defaults(task="json")
    json_cmd_parser.add_argument(
            "type", help="the protobuf message type")
    json_cmd_parser.add_argument(
            "file", help="the file to read, or stdin if not specified", nargs="?")
    json_cmd_parser.add_argument(
            "--output", "-o", help="a file to write to, or stdout if not specified")
    json_cmd_parser.add_argument(
            "--internal-type", "-i", help="the protobuf message type represented by any bytes-type fields, if any")

    proto_cmd_parser = subparsers.add_parser(
            "proto", help="read a JSON or protobuf message and output protobuf")
    proto_cmd_parser.set_defaults(task="proto")
    proto_cmd_parser.add_argument(
            "type", help="the protobuf message type")
    proto_cmd_parser.add_argument(
            "file", help="the file to read, or stdin if not specified", nargs="?")
    proto_cmd_parser.add_argument(
            "--output", "-o", help="a file to write to, or stdout if not specified")
    proto_cmd_parser.add_argument(
            "--internal-type", "-i", help="the protobuf message type represented by any bytes-type fields, if any")

    edit_cmd_parser = subparsers.add_parser(
            "edit", help="create or edit a protobuf message in an editor")
    edit_cmd_parser.set_defaults(task="edit")
    edit_cmd_parser.add_argument(
            "type", help="the protobuf message type")
    edit_group = edit_cmd_parser.add_mutually_exclusive_group()
    edit_group.add_argument(
            "file", help="an input file to use as a template, or a default message if not specified", nargs="?")
    edit_group.add_argument(
            "--empty", "-e",
            help="use a completely empty message instead of the default",
            action="store_true")
    edit_group.add_argument(
            "--recent", help="use the most recent edit as a template",
            action="store_true")
    edit_cmd_parser.add_argument(
            "--output", "-o", help="a file to write to, or stdout if not specified")
    edit_cmd_parser.add_argument(
            "--internal-type", "-i", help="the protobuf message type represented by any bytes-type fields, if any")

    register_cmd_parser = subparsers.add_parser(
            "register", help="register a folder of protobuf definitions")
    register_cmd_parser.set_defaults(task="register")
    register_group = register_cmd_parser.add_mutually_exclusive_group(required=True)
    register_group.add_argument(
            "path", help="path to a folder containing protobuf definitions (searched recursively)", nargs="?")
    register_group.add_argument(
            "--list", "-l", help="list the paths that are currently registered",
            action="store_true")
    register_group.add_argument(
            "--recompile",
            help="recompiles registered proto definitions (this happens automatically when registering)",
            action="store_true")
    register_cmd_parser.add_argument(
            "--remove", "-r", help="un-register this path",
            action="store_true")

    args = vars(parser.parse_args())
    if "task" not in args:
        parser.print_help()
        exit(2)
    protopad(args)
